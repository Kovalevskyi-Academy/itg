#timeout: 150s

options:
  dynamic_substitutions: true
  substitution_option: 'ALLOW_LOOSE'

substitutions:
  # $REPO_NAME means GitHub's repo name. It will be container name
  _IMAGE: 'europe-docker.pkg.dev/${PROJECT_ID}/api-rest/${REPO_NAME}'
  _PG_POD_NAME: ''

steps:

#
#  # Валидация кода
#  - name: 'maven:3.8.4-eclipse-temurin-17-alpine'
#    entrypoint: 'mvn'
#    args: [ 'validate' ]
#    dir: 'api'
#  # Unit тесты
#  - name: 'maven:3.8.4-eclipse-temurin-17-alpine'
#    entrypoint: 'mvn'
#    args: [ 'test' ]
#    dir: 'api'
#  # Собираем джарник.
#  - name: 'maven:3.8.4-eclipse-temurin-17-alpine'
#    entrypoint: 'mvn'
#    args: ['package', '-Dmaven.test.skip=true']
#    dir: 'api'
#  # Засовываем джарник в хранилище
#  - name: 'gcr.io/google.com/cloudsdktool/cloud-sdk:alpine'
#    entrypoint: 'gsutil'
#    args: ['cp', 'target/a*.jar', 'gs://prod-rest_cloudbuild/api-rest/a*.jar']
#    dir: 'api'
#
#  # Распаковываем джарник. Это позволит лучше использовать слои контейнера.
#  - name: 'maven:3.8.4-eclipse-temurin-17-alpine'
#    entrypoint: 'bash'
#    args: ['-c', 'mkdir -p target/dependency && (cd target/dependency; jar -xfv ../*.jar) && echo "jar unpack success"']
#    dir: 'api'
#  # Пулим старый контейнер, если он есть.
#  - name: 'docker:20.10.12-alpine3.15'
#    entrypoint: 'sh'
#    args: ['-c', 'docker pull ${_IMAGE}:latest || exit 0']
#    dir: 'api'
#  # Билдим контейнер используя кэш спуленного ранее контейнера,
#  # на основе указанного докерфайла.
#  - name: 'docker:20.10.12-alpine3.15'
#    args: ['build',
#      # $SHORT_SHA is a part of hash of git commit. It will be container tag.
#           '-t', '${_IMAGE}:${SHORT_SHA}',
#           '-t', '${_IMAGE}:latest',
#           '--cache-from', '${_IMAGE}:latest',
#           '-f', 'api.dockerfile',
#           '.']
#    dir: 'api'
#  # Push image to artifact registry
#  - name: 'docker:20.10.12-alpine3.15'
#    args: [ 'push', '--all-tags', '${_IMAGE}']
#    dir: 'api'

  # Kubernetes RUN DB
  - name: 'gcr.io/cloud-builders/gke-deploy'
    id: 'deploy-db'
    args: ['run',
           '--filename', './k8b/db/',
           '--location', 'europe-north1',
           '--cluster', 'my-autopilot-cluster']
  # Little sleep before start tests
  - name: 'gcr.io/cloud-builders/gke-deploy'
    id: 'waiting-for-DB'
    waitFor: ['deploy-db']
    entrypoint: 'kubectl'
    args: ['get', 'pod']
  # Test DB in pod
  - name: 'gcr.io/cloud-builders/gke-deploy'
    id: 'test-db'
    waitFor: ['waiting-for-DB']
    entrypoint: 'bash'
    args:
      - '-c'
      - |
          pg_pod_name=$(kubectl get pod --selector=app=pg -o jsonpath={.items..metadata.name})
          is_pod_started=$(kubectl get pod "$pg_pod_name" -o jsonpath={.status..started})
          while [ ! "$is_pod_started" ]
          do
          echo "$is_pod_started"
          is_pod_started=$(kubectl get pod "$pg_pod_name" -o jsonpath={.status..started})
          done
          echo 'PG IS STARTED!'
          echo 'sleeping'
          sleep 5
          kubectl exec $pg_pod_name -- /bin/sh -c 'pgbench -i -U testUSER -d testDB'
    # TODO fix security!

#  # Run REST-API
#  - name: 'gcr.io/cloud-builders/gke-deploy'
#    id: 'deploy-rest'
#    waitFor:
#      - 'test-db'
#    args: ['run',
#           '--filename', './k8b/db/',
#           '--location', 'europe-north1',
#           '--cluster', 'my-autopilot-cluster' ]
#
#  # Wait for rest start
#  - name: 'gcr.io/cloud-builders/gke-deploy'
#    id: 'check-start'
#    waitFor: ['deploy-rest']
#    entrypoint: 'bash'
#    args:
#      - '-c'
#      - |
#
#
#
#  # Test REST-API
#  - name: 'gcr.io/cloud-builders/gke-deploy'
#    id: 'test-REST-API'



  # Delete Db from cluster
  - name: 'gcr.io/cloud-builders/gke-deploy'
    id: 'delete-postgres'
    entrypoint: 'kubectl'
    args: ['delete', '--filename', './k8b/db/']
  # Delete PERSISTENT VOLUME
  - name: 'gcr.io/cloud-builders/gke-deploy'
    id: 'delete-persistent-volume'
    waitFor: ['delete-postgres']
    entrypoint: 'bash'
    args:
      - '-c'
      - |
          pvc_name=$(kubectl get pvc --selector=$sel -o jsonpath={.items..metadata.name})
          kubectl delete pvc $pvc_name
